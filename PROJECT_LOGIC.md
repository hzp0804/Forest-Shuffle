# Forest Shuffle 项目逻辑与数据结构说明

本文档旨在记录项目的核心逻辑、数据结构定义及关键处理流程，以防止未来开发中出现理解偏差。

## 1. 卡牌数据结构 (`cardData.js`)

卡牌数据通过 `$f` 函数定义，核心结构如下：

```javascript
$f([
  CARD_TYPE, // 参数1: 卡牌类型 (TREE, H_CARD, V_CARD)
  [SPECIES_1, SPECIES_2], // 参数2: 物种数组
  [SYMBOL_1, SYMBOL_2], // 参数3: 树木符号(颜色)数组
  DECK_TYPE, // 参数4: 牌堆类型
]);
```

### 关键映射规则

- **严格对应关系**：
  - `SPECIES_1` (数组第 0 项) **严格对应** `SYMBOL_1` (数组第 0 项)。
  - `SPECIES_2` (数组第 1 项) **严格对应** `SYMBOL_2` (数组第 1 项)。
- **含义**：
  - 当卡牌作为 **左/上** 侧使用时，生效的是索引 **0** 的物种和符号。
  - 当卡牌作为 **右/下** 侧使用时，生效的是索引 **1** 的物种和符号。
- **树木符号 (tree_symbol)**：
  - 在本项目中，`tree_symbol` 代表卡牌的**颜色/门类**。
  - 例如：西方狍 (Roe Deer) 对应的符号是 `LINDEN` (椴树/蓝色)，这意味着它是一张“蓝色牌”。

## 2. 卡牌处理与插槽逻辑 (`utils.js`)

为了确保游戏逻辑（如计分、显示）正确，所有卡牌在进入由于计算前必须经过 **"充实" (Enrichment)** 处理。

### 核心函数: `enrichCardWithSpecies(card, side)`

- **输入**：原始卡牌对象，以及由于所在的插槽位置 (`side`: 'top', 'bottom', 'left', 'right', 'center').
- **逻辑**：
  1.  判断卡牌类型 (`H_CARD` 或 `V_CARD`).
  2.  根据 `side` 确定激活的索引 `index`：
      - `left` / `top` / `center` -> `index = 0`
      - `right` / `bottom` -> `index = 1`
  3.  **数据裁切**：
      - 从 `speciesDetails` 中只提取第 `index` 个物种的详细信息（名称、标签等）。
      - 从 `tree_symbol` 中只提取第 `index` 个符号。
- **输出**：一个“生效后”的卡牌对象。该对象现在 **只包含** 激活那一侧的属性。
  - 例如：一张左右分割卡，如果插在左边，处理后的对象就没有右边的任何信息，它的 `tree_symbol` 数组里只有左边的那个符号。

### 森林遍历 (`enrichForest`)

- 在处理玩家森林 (`playerState.forest`) 时，系统会自动遍历每个树木 (`center`) 及其四个插槽 (`slots`)。
- 对每个插槽调用 `enrichCardWithSpecies` 并传入正确的 `side`。
- **结果**：计分函数接收到的 `forest` 数据中，每一张卡都已经明确了它是哪一半，属性也是确定的。

### 颜色牌 (`color`)

- 游戏用树木来代表颜色，CARDS_DATA 的第三个参数也就是所谓的颜色
- 椴树：黄色
- 橡树：棕色
- 银杉：蓝色
- 桦树：青色
- 山毛榉：深绿色
- 梧桐：红色
- 冷杉：浅蓝色
- 欧洲七叶树：橙色
- 欧洲落叶松：紫色
- 瑞士石松：粉色

## 3. 计分逻辑 (`score.js`)

计分完全依赖于上述“充实”后的数据。

### 通用原则

- 计分时不关心卡牌原本是长什么样的（双面），只关心它**当前生效**的属性。

### 关键案例：颜色/符号匹配 (SCORING_TYPES.PER_TAG_ON_MATCHING)

- **典型代表**：西方狍 (Western Roe Deer)。
- **规则**：每有一张带有匹配树木符号（颜色）的牌得 3 分。
- **实现逻辑**：
  1.  获取当前计分卡牌（西方狍）的生效符号（例如 `['LINDEN']`）。
  2.  遍历整个森林（包括所有的**树木中心卡**和所有**插槽卡**）。
  3.  检查每一张卡的生效符号是否包含目标符号。
  4.  统计匹配数量（包含它自己）。
  5.  得分 = 数量 × 3。
- **注意**：这里不是比较“它插在什么树上”，而是比较“全森林里有多少张同色的卡”。这也是为什么数据的颜色定义必须准确的原因。

## 4. 易错点备忘

1.  **Card 101 等数据录入**：
    - 必须确保 `cardData.js` 中 参数 2 和 参数 3 的顺序是一致的。
    - 不要被卡图的视觉左右迷惑，始终以“生效逻辑”为准（Index 0 = Left/Top, Index 1 = Right/Bottom）。
2.  **树木符号本身**：
    - 树木也拥有符号（例如椴树卡拥有椴树符号）。
    - 在统计“匹配符号的卡牌”时，必须包含树木本身（若符号匹配）。
3.  **调试**：
    - 如果发现得分不对，首先检查 `enrichCardWithSpecies` 后该卡的 `tree_symbol` 是否正确。
    - 其次检查 `cardData.js` 中是否发生了颜色与物种的错位。

---

_文档更新时间：2025-12-17_
