# 翻牌逻辑重构总结

## 重构目标

重构翻牌逻辑，从回合开始时进行计数，每打出一张树木到森林，count+1，如果有奖励行动，继续打了树木，那么需要再次累加,直到本回合所有行动结束，根据计数器翻牌，回合结束。

## 重构内容

### 1. 回合开始时初始化计数器

**位置**: `game.js` - `processGameUpdate` 方法

**修改内容**:

- 在回合切换时（`turnChanged === true`），初始化 `this.pendingRevealCount = 0`
- 添加日志输出：`🔄 回合切换，翻牌计数器已重置为 0`

```javascript
// 1. 回合切换逻辑 (标记待提示 + 重置选择状态 + 初始化翻牌计数器)
if (turnChanged) {
  // 回合切换时，重置选择状态
  processedData.primarySelection = null;
  processedData.selectedSlot = null;
  processedData.lastActivePlayer = currentActive;
  // 初始化翻牌计数器为 0（新回合开始）
  this.pendingRevealCount = 0;
  console.log("🔄 回合切换，翻牌计数器已重置为 0");
  processedData.lastTurnCount = currentTurnCount;
}
```

### 2. 每次打出树木时累加计数器

#### 2.1 特殊模式下打出树木

**位置**: `game.js` - `onConfirmPlay` 方法（特殊模式分支）

**修改内容**:

- 每次在特殊模式下打出树木时，累加 `this.pendingRevealCount`
- 包括奖励行动中打出的树木（如鼼鼠、蝙蝠等效果触发的免费打牌）
- 添加详细的日志输出

```javascript
// 如果打出的是树木，累加翻牌计数器
// 这里包括奖励行动中打出的树木（如鼼鼠、蝙蝠等效果触发的免费打牌）
if (isPlayedAsTree) {
  updates[`gameState.accumulatedRewards.revealCount`] = db.command.inc(1);
  this.pendingRevealCount = (this.pendingRevealCount || 0) + 1;
  console.log(
    "🌳 特殊模式打出树木，计数器+1。当前总计:",
    this.pendingRevealCount
  );
} else {
  console.warn("⚠️ 非树木卡牌，未增加计数");
}
```

#### 2.2 普通模式下打出树木

**位置**: `game.js` - `onConfirmPlay` 方法（普通模式分支）

**修改内容**:

- 每次在普通模式下打出树木时，累加 `this.pendingRevealCount`
- 添加详细的日志输出

```javascript
// 1. 累加计数（每次打出树木时）
if (isPlayedAsTree) {
  this.pendingRevealCount = (this.pendingRevealCount || 0) + 1;
  console.log(
    "🌳 普通模式打出树木，计数器+1。当前总计:",
    this.pendingRevealCount
  );
}

// 2. 决定是否立即翻牌还是推迟到回合结束
if (shouldDeferReveal) {
  console.log("🕒 有后续行动（奖励或额外回合），翻牌推迟到回合结束");
} else {
  // 立即结算所有累积的翻牌（无后续行动，回合结束）
  const totalReveal = this.pendingRevealCount || 0;
  this.pendingRevealCount = 0; // Reset
  // ... 执行翻牌逻辑
}
```

### 3. 回合结束时统一翻牌

**位置**: `game.js` - `finalizeAction` 方法

**修改内容**:

- 在回合结束时，根据累积的 `pendingRevealCount` 统一执行翻牌
- 优先使用本地计数器（更准确），数据库计数作为备份（断线重连场景）
- 翻牌完成后重置计数器为 0
- 添加详细的日志输出

```javascript
// === 处理累积的翻牌 (回合结束时统一翻牌) ===
// 使用本地计数器 pendingRevealCount，该计数器在回合开始时初始化为 0
// 每次打出树木时累加，包括奖励行动中打出的树木
console.log("📊 回合结束翻牌统计:", {
  本回合打出树木数: this.pendingRevealCount || 0,
  数据库累积计数: rewards.revealCount || 0,
});

// 优先使用本地计数器（更准确），数据库计数作为备份（断线重连场景）
const pendingReveal = Math.max(
  this.pendingRevealCount || 0,
  rewards.revealCount || 0
);

if (pendingReveal > 0) {
  console.log(`🎴 回合结束，开始翻牌: ${pendingReveal} 张`);

  // ... 执行翻牌逻辑 ...

  console.log(`✅ 翻牌完成: ${revealedCards.length} 张卡牌已放入空地`);
}

// 重置翻牌计数器（回合结束后清零，等待下一回合开始时重新初始化）
// 注意：实际的初始化在回合切换时进行（processGameUpdate 中的 turnChanged 逻辑）
this.pendingRevealCount = 0;
console.log("🔄 翻牌计数器已重置为 0");
```

## 重构效果

### 优势

1. **逻辑清晰**: 回合开始初始化 → 打牌时累加 → 回合结束统一翻牌
2. **准确计数**: 包括所有奖励行动中打出的树木
3. **易于调试**: 添加了详细的日志输出，方便追踪计数器状态
4. **容错性强**: 同时维护本地计数和数据库计数，支持断线重连场景

### 工作流程

```
回合开始 (processGameUpdate)
  ↓
初始化 pendingRevealCount = 0
  ↓
打出树木 (onConfirmPlay - 普通模式/特殊模式)
  ↓
pendingRevealCount += 1
  ↓
有奖励行动？
  ├─ 是 → 继续打牌 → pendingRevealCount += 1
  └─ 否 → 回合结束 (finalizeAction)
       ↓
     根据 pendingRevealCount 翻牌
       ↓
     重置 pendingRevealCount = 0
       ↓
     等待下一回合
```

## 测试建议

1. **单次打牌**: 打出一棵树木，验证翻 1 张牌
2. **连续打牌**: 通过奖励行动连续打出多棵树木，验证翻多张牌
3. **混合打牌**: 打出树木 + 非树木卡牌，验证只有树木计数
4. **回合切换**: 验证新回合开始时计数器重置为 0
5. **断线重连**: 验证断线重连后计数器恢复正常

## 相关文件

- `miniprogram/pages/game/game.js` - 主要修改文件
- `miniprogram/utils/round.js` - 回合逻辑工具类（未修改）
