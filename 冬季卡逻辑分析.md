# 冬季卡逻辑分析与实现建议

## 当前实现

### 1. 冬季卡的创建

**位置**: `miniprogram/pages/lobby/lobby.js` 第 871-904 行

```javascript
// 添加 3 张冬季卡
const WINTER_CARD_ID = "Winter";
for (let w = 1; w <= WINTER_CARD_COUNT; w++) {
  bottomPart.push({
    id: WINTER_CARD_ID,
    uid: `${WINTER_CARD_ID}_${w}_${Math.random().toString(36).slice(2)}`,
    type: "Winter",
  });
}
```

**特点**:

- 冬季卡 ID: `"Winter"`
- 冬季卡类型: `"Winter"`
- 数量: 3 张
- 位置: 洗入牌库底部(最后 30 张左右)

### 2. 抽牌逻辑

**位置**: `miniprogram/pages/game/game.js` 第 1514-1556 行

```javascript
executeDrawFromDeck() {
  // ...
  const card = newDeck.shift(); // 从牌库顶部抽一张
  newHand.push(card);           // 直接加入手牌
  // ...
  this.submitGameUpdate(updates, null, `从牌堆摸了一张牌`);
}
```

**问题**: ❌ **没有检查是否为冬季卡!**

### 3. 当前行为

```
玩家抽到冬季卡:
1. 冬季卡被加入手牌 ❌
2. 可以像普通卡一样打出 ❌
3. 游戏继续进行 ❌
```

## 游戏规则

### 冬季卡的作用

根据《Forest Shuffle》规则:

1. **游戏结束触发器**: 当有玩家抽到冬季卡时,游戏立即结束
2. **不加入手牌**: 冬季卡不应该加入玩家手牌
3. **触发结算**: 抽到冬季卡后,进入最终计分阶段

### 正确流程

```
玩家抽到冬季卡:
1. 检测到冬季卡 ✅
2. 显示"冬季来临,游戏结束"提示 ✅
3. 冬季卡不加入手牌 ✅
4. 触发游戏结束逻辑 ✅
5. 进入最终计分 ✅
```

## 需要实现的逻辑

### 1. 检测冬季卡

#### 方法 1: 通过 ID 检测

```javascript
const isWinterCard = (card) => {
  return card.id === "Winter" || card.id === "winter";
};
```

#### 方法 2: 通过类型检测

```javascript
const isWinterCard = (card) => {
  return card.type === "Winter" || card.type === CARD_TYPES.W_CARD;
};
```

**建议**: 使用方法 2,因为类型更可靠

### 2. 修改抽牌逻辑

```javascript
executeDrawFromDeck() {
  const { deck, playerStates, openId, turnAction } = this.data;
  const curTotal = (turnAction?.drawnCount || 0) + (turnAction?.takenCount || 0);

  // 检查手牌上限
  if (playerStates[openId].hand.length >= 10) {
    wx.showToast({ title: "手牌已满", icon: "none" });
    return;
  }

  if (curTotal >= 2 || deck.length === 0) return;

  const newDeck = [...deck];
  const card = newDeck.shift();

  // ⭐ 检测冬季卡
  const isWinterCard = card.type === "Winter" || card.type === CARD_TYPES.W_CARD;

  if (isWinterCard) {
    // 触发游戏结束
    this.handleWinterCard(card);
    return;
  }

  // 正常抽牌逻辑
  const newHand = [...playerStates[openId].hand];
  newHand.push(card);
  // ...
}
```

### 3. 处理冬季卡

```javascript
handleWinterCard(winterCard) {
  const { openId, players } = this.data;

  // 1. 显示冬季来临提示
  wx.showModal({
    title: '❄️ 冬季来临',
    content: '游戏结束!即将进入最终计分...',
    showCancel: false,
    success: () => {
      // 2. 更新游戏状态为结束
      const updates = {
        'gameState.isGameOver': true,
        'gameState.gameEndReason': 'WINTER_CARD',
        'gameState.lastEvent': {
          type: 'WINTER_CARD',
          playerOpenId: openId,
          playerNick: players.find(p => p.openId === openId)?.nickName || '玩家',
          playerAvatar: players.find(p => p.openId === openId)?.avatarUrl || '',
          mainCard: Utils.enrichCard(winterCard),
          timestamp: Date.now()
        }
      };

      // 3. 提交更新
      this.submitGameUpdate(updates, null, '抽到冬季卡,游戏结束');

      // 4. 延迟跳转到结算页面
      setTimeout(() => {
        this.navigateToGameOver();
      }, 2000);
    }
  });
}
```

### 4. 游戏结束动画

在 `game.wxml` 中添加冬季卡事件的显示:

```xml
<!-- 冬季卡事件 -->
<block wx:if="{{currentEvent.type === 'WINTER_CARD'}}">
  <view class="event-content winter-card">
    <view class="winter-icon">❄️</view>
    <view class="winter-title">冬季来临</view>
    <view class="winter-text">游戏结束</view>
    <view class="card-preview">
      <view class="card-sprite-native"
            style="background-image: url({{currentEvent.mainCard.bgImg}});
                   background-size: {{currentEvent.mainCard.bgSize}};
                   background-position: {{currentEvent.mainCard.bgPosition}};">
      </view>
    </view>
  </view>
</block>
```

### 5. 结算页面

创建游戏结束页面 `pages/game-over/game-over`:

```javascript
// game-over.js
Page({
  data: {
    players: [],
    winner: null,
    myRank: 0,
  },

  onLoad(options) {
    const roomId = options.roomId;
    // 加载游戏数据
    this.loadGameResult(roomId);
  },

  async loadGameResult(roomId) {
    // 从数据库加载最终游戏状态
    const res = await db.collection("rooms").doc(roomId).get();
    const gameState = res.data.gameState;

    // 计算所有玩家的最终得分
    const players = this.calculateFinalScores(gameState);

    // 排序
    players.sort((a, b) => b.score - a.score);

    // 确定获胜者
    const winner = players[0];

    this.setData({
      players,
      winner,
      myRank: players.findIndex((p) => p.openId === this.data.openId) + 1,
    });
  },
});
```

## 数据库结构调整

### 添加游戏结束状态

```javascript
gameState: {
  // ... 现有字段
  isGameOver: false,           // 游戏是否结束
  gameEndReason: null,         // 结束原因: 'WINTER_CARD' | 'DECK_EMPTY' | 'MANUAL'
  gameEndTime: null,           // 结束时间
  finalScores: {}              // 最终得分 { openId: score }
}
```

## 实现优先级

### 高优先级 🔴

1. **检测冬季卡**: 在抽牌时检测是否为冬季卡
2. **阻止加入手牌**: 冬季卡不应该加入手牌
3. **显示提示**: 告知玩家游戏结束

### 中优先级 🟡

4. **游戏结束逻辑**: 设置游戏状态为结束
5. **冬季卡动画**: 显示冬季来临的特殊动画
6. **禁用操作**: 游戏结束后禁用所有操作

### 低优先级 🟢

7. **结算页面**: 创建专门的游戏结束页面
8. **最终计分**: 计算并显示所有玩家的最终得分
9. **排名展示**: 显示玩家排名和获胜者

## 测试场景

### 场景 1: 正常抽到冬季卡

1. 玩家 A 摸牌
2. 抽到冬季卡
3. **预期**:
   - 显示"冬季来临"提示 ✅
   - 冬季卡不加入手牌 ✅
   - 游戏状态变为结束 ✅

### 场景 2: 奖励摸牌抽到冬季卡

1. 玩家 A 出牌触发奖励摸 2 张牌
2. 第一张正常,第二张是冬季卡
3. **预期**:
   - 第一张加入手牌 ✅
   - 第二张触发游戏结束 ✅

### 场景 3: 多人同时摸牌

1. 玩家 A 的回合
2. 玩家 A 抽到冬季卡
3. **预期**:
   - 所有玩家都看到游戏结束提示 ✅
   - 通过 `gameWatcher` 同步状态 ✅

## 代码位置

### 需要修改的文件

1. `miniprogram/pages/game/game.js`

   - `executeDrawFromDeck()` - 添加冬季卡检测
   - 新增 `handleWinterCard()` - 处理冬季卡逻辑

2. `miniprogram/pages/game/game.wxml`

   - 添加冬季卡事件的显示模板

3. `miniprogram/pages/game/game.wxss`

   - 添加冬季卡动画样式

4. 新建 `miniprogram/pages/game-over/`
   - 游戏结束页面

## 总结

### 当前状态

❌ **冬季卡逻辑未实现**

- 抽到冬季卡会被当作普通卡处理
- 不会触发游戏结束
- 不符合游戏规则

### 需要实现

✅ **完整的冬季卡逻辑**

1. 检测冬季卡
2. 触发游戏结束
3. 显示特殊动画
4. 进入结算页面

### 建议

**优先实现高优先级功能**,确保基本的游戏规则正确,然后再完善动画和结算页面。
