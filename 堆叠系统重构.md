# 堆叠系统重构总结

## 核心数据结构

```javascript
{
  ...cardData,
  list: [card1, card2, ...],  // 所有堆叠的卡片（包括当前显示的）
  max: 2,                      // 最大容量（99 表示无限）
  slotConfig: {...}            // 可选：宿主堆叠配置
}
```

## 三种堆叠模式

### 1. 自我堆叠（大蟾蜍、欧洲野兔）

**特征**：

- 卡片自带 `CAPACITY_INCREASE` 或 `CAPACITY_UNLIMITED` 效果
- `effectConfig.target` 指向自己的名称

**赋予时机**：打出**第一张**时

**实现**：

```javascript
// 第一张
{
  ...primaryCard,
  list: [primaryCard],
  max: effectConfig.value || 99,  // CAPACITY_INCREASE: value, CAPACITY_UNLIMITED: 99
  slotConfig: null
}

// 第二张
{
  ...primaryCard,  // 用新卡覆盖
  list: [第一张, 第二张],
  max: 2,
  slotConfig: null
}
```

### 2. 宿主堆叠（刺荨麻 + 蝴蝶）

**特征**：

- 宿主卡片（刺荨麻）有 `CAPACITY_SHARE_SLOT` 效果
- 客体卡片（蝴蝶）有对应的 tag

**赋予时机**：

- 刺荨麻打出时：**不赋予**（刺荨麻本身不堆叠）
- 第一只蝴蝶打出时：**赋予**（因为刺荨麻已存在，`isStackMode=true`）
- 刺荨麻打出后：**转换**已存在的蝴蝶为堆叠模式

**实现**：

```javascript
// 第一只蝴蝶（刺荨麻已存在）
{
  ...primaryCard,
  list: [primaryCard],
  max: 99,
  slotConfig: {
    accepts: { tags: ['蝴蝶'] },
    capacity: 99
  }
}

// 第二只蝴蝶
{
  ...primaryCard,  // 用新卡覆盖
  list: [第一只, 第二只],
  max: 99,
  slotConfig: {...}
}
```

### 3. 普通卡片（无堆叠）

**实现**：

```javascript
{
  ...primaryCard,
  // 没有 list 和 max 字段
}
```

## 统一逻辑流程

### 打出卡片到已有卡片的槽位

```javascript
if (existingCard) {
  // 1. 判断是否允许堆叠
  const isCapacityIncrease = ec && ec.type === 'CAPACITY_INCREASE' && ec.target === targetName;
  const isCapacityUnlimited = ec && ec.type === 'CAPACITY_UNLIMITED' && ec.target === targetName;
  const isSelfStacking = isCapacityIncrease || isCapacityUnlimited;

  if (isStackMode || existingCard.slotConfig || isSelfStacking) {
    // 2. 获取当前堆叠状态
    const currentList = existingCard.list || [];
    const currentMax = existingCard.max || 1;

    // 3. 检查容量
    if (currentList.length >= currentMax) {
      // 提示：插槽已满
      return;
    }

    // 4. 推入新卡片
    const newList = [...currentList, primaryCard];

    // 5. 用新卡片覆盖槽位
    tTree.slots[side] = {
      ...primaryCard,      // 显示新卡片
      list: newList,       // 包含所有卡片
      max: currentMax,     // 继承容量
      slotConfig: ...      // 继承或初始化配置
    };
  } else {
    // 不允许堆叠
    // 提示：该插槽已有卡片
  }
}
```

### 打出卡片到空槽位

```javascript
else {
  // 1. 判断是否需要堆叠效果
  const isPrimarySelfStacking = pec &&
    (pec.type === 'CAPACITY_INCREASE' || pec.type === 'CAPACITY_UNLIMITED') &&
    pec.target === pTargetName;

  if (isStackMode) {
    // 宿主堆叠模式（刺荨麻已存在）
    tTree.slots[side] = {
      ...primaryCard,
      list: [primaryCard],
      max: 99,
      slotConfig: {
        accepts: { tags: [enabler.effectConfig.tag] },
        capacity: 99
      }
    };
  } else if (isPrimarySelfStacking) {
    // 自我堆叠模式（大蟾蜍/野兔第一张）
    const maxCapacity = pec.type === 'CAPACITY_UNLIMITED' ? 99 : (pec.value || 1);
    tTree.slots[side] = {
      ...primaryCard,
      list: [primaryCard],
      max: maxCapacity,
      slotConfig: null
    };
  } else {
    // 普通卡片
    tTree.slots[side] = primaryCard;
  }
}
```

## UI 显示

### 角标显示条件

```javascript
// WXML
wx:if="{{item.slots.top.max}}"  // 有 max 字段就显示角标
```

### 角标数字

```javascript
// stackCount 在 enrichCard 中计算
enriched.stackCount = enriched.list ? enriched.list.length : 1;
```

### 点击角标

```javascript
onStackTap(e) {
  const slotCard = tree.slots[side];
  const cardsToShow = slotCard.list || [];  // 显示所有卡片
  this.setData({
    stackModalVisible: true,
    stackModalCards: cardsToShow
  });
}
```

## 计分系统适配

### 需要修改的地方

所有使用 `stackedCards` 的地方改为 `list`，但注意语义差异：

**旧逻辑**：

```javascript
// stackedCards 不包含当前显示的卡片
const count = stackedCards.length; // 被压在下面的卡片数
```

**新逻辑**：

```javascript
// list 包含所有卡片（包括当前显示的）
const count = list.length; // 所有卡片数
```

### 特殊情况：大蟾蜍计分

```javascript
// PER_STACKED_CARD 类型
// 旧逻辑：每张堆叠在下面的卡片得分
const score = stackedCards.length * value;

// 新逻辑：每张堆叠的卡片得分（不包括自己）
const score = (list.length - 1) * value;
```

## 关键优势

1. **统一性**：三种堆叠模式使用相同的数据结构和逻辑
2. **清晰性**：`list` 语义明确（所有卡片），`max` 表示容量
3. **可扩展性**：新增堆叠类型只需配置 `max` 和 `slotConfig`
4. **UI 友好**：`list.length` 直接对应角标数字
